

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/%E5%A4%B4%E5%83%8F.jpeg">
  <link rel="icon" href="/img/%E5%A4%B4%E5%83%8F.jpeg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lluvia Luo">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux同步与锁机制包括互斥量、条件变量、死锁预防、可重入锁和读写锁。互斥量通过futex实现，结合用户态和内核态操作，减少不必要的系统调用。条件变量用于线程间同步，与互斥量结合使用，处理虚假唤醒问题。死锁预防通过破坏产生死锁的四个必要条件之一来实现。可重入锁允许同一进程多次获取锁，而读写锁允许多个读操作或单个写操作，提高并发效率。乐观锁与悲观锁是控制并发访问的理念，悲观锁通过加锁防止冲突，乐观">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux:同步与锁">
<meta property="og:url" content="https://lluvialuo.github.io/2024/05/12/Linux-%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%94%81/index.html">
<meta property="og:site_name" content="Lluvia&#39;s blog">
<meta property="og:description" content="Linux同步与锁机制包括互斥量、条件变量、死锁预防、可重入锁和读写锁。互斥量通过futex实现，结合用户态和内核态操作，减少不必要的系统调用。条件变量用于线程间同步，与互斥量结合使用，处理虚假唤醒问题。死锁预防通过破坏产生死锁的四个必要条件之一来实现。可重入锁允许同一进程多次获取锁，而读写锁允许多个读操作或单个写操作，提高并发效率。乐观锁与悲观锁是控制并发访问的理念，悲观锁通过加锁防止冲突，乐观">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lluvialuo.github.io/2024/05/12/Linux-%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%94%81/futex.png">
<meta property="og:image" content="https://lluvialuo.github.io/2024/05/12/Linux-%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%94%81/dead_lock.png">
<meta property="article:published_time" content="2024-05-12T12:49:34.000Z">
<meta property="article:modified_time" content="2024-05-13T10:56:57.886Z">
<meta property="article:author" content="Lluvia Luo">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lluvialuo.github.io/2024/05/12/Linux-%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%94%81/futex.png">
  
  
  
  <title>Linux:同步与锁 - Lluvia&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lluvialuo.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"GYXWwiquLells7Jk5YnXDL14-gzGzoHsz","app_key":"ZwOt64lE5AeeAOjGF9nhJl9b","server_url":"https://gyxwwiqu.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lluvia</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/mainpage.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Linux:同步与锁"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-12 20:49" pubdate>
          2024年5月12日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          53 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Linux:同步与锁</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2024年5月13日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="一、互斥量"><a href="#一、互斥量" class="headerlink" title="一、互斥量"></a>一、互斥量</h1><ul>
<li>在Linux中要实现互斥锁mutex最简单的办法是通过操作系统提供的信号量来实现，但是目前在C++中调用pthread_mutex_lock并不是直接通过操作系统的信号量原语来实现的，而是使用了优化过的futex来实现。</li>
</ul>
<h2 id="1-1-futex基本概念"><a href="#1-1-futex基本概念" class="headerlink" title="1.1 futex基本概念"></a>1.1 futex基本概念</h2><ul>
<li>Futex 是Fast Userspace muTexes的缩写，在传统的Unix系统中当进程间要同步的时候必须要通过系统调用(如semop())在内核中完成。而大部分时候其实并没有另外的程序在竞争这个信号量，但是在这种情况下，这个进程也要陷入内核去看看有没有进程和它竞争，退出的时侯还要陷入内核去看看有没有进程等待在同一同步变量上。这些不必要的系统调用(或者说内核陷入)造成了大量的性能开销。</li>
<li>Futex是一种用户态和内核态混合的同步机制。首先，同步的进程间通过mmap共享一段内存，futex变量就位于这段共享的内存中且操作是原子的，当进程尝试进入互斥区或者退出互斥区的时候，先去查看共享内存中的futex变量，如果没有竞争发生，则只修改futex,而不用再执行系统调用了。</li>
<li>当通过访问futex变量告诉进程有竞争发生，则还是得执行系统调用去完成相应的处理(wait 或者 wake up)。简单的说，futex就是通过在用户态的检查，（motivation）如果了解到没有竞争就不用陷入内核了，大大提高了low-contention时候的效率。</li>
</ul>
<h2 id="1-2-futex实现原理"><a href="#1-2-futex实现原理" class="headerlink" title="1.2 futex实现原理"></a>1.2 futex实现原理</h2><ul>
<li>futex包含了用户态和内核态的两部分行为，用户态由glibc-nptl库的pthread_mutex实现，内核态由futex系统调用支持。</li>
</ul>
<h3 id="1-2-1-用户态"><a href="#1-2-1-用户态" class="headerlink" title="1.2.1 用户态"></a>1.2.1 用户态</h3><ul>
<li>C++中的std::mutex只是对glibc-nptl库的pthread_mutex_t的一层封装，pthread_mutex_t其实是个union结构，它的主干部分是其中的__pthread_mutex_s，大概成员为：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> &#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__pthread_mutex_s</span> &#123;<br>    <span class="hljs-type">int</span> __lock;                <span class="hljs-comment">// !&lt; 表示是否被加锁，是否存在竞争</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __count;       <span class="hljs-comment">//!&lt; __kind代表可重入锁时，重复上锁会对__count进行递增。</span><br>    <span class="hljs-type">int</span> __owner;                <span class="hljs-comment">//!&lt; 持有线程的线程ID。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __nusers;<br>    <span class="hljs-type">int</span> __kind;                 <span class="hljs-comment">//!&lt; 上锁类型。</span><br>    <span class="hljs-type">int</span> __spins;<br>    <span class="hljs-type">__pthread_list_t</span> __list;<br>  &#125; __data;<br>&#125; <span class="hljs-type">pthread_mutex_t</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>__lock是CAS操作对象，其值有三种状态：</p>
<ul>
<li><p>0， 表示还没有进程&#x2F;线程获得这把锁</p>
</li>
<li><p>1， 表示有进程&#x2F;线程已经获得了这个锁</p>
</li>
<li><p>2， 当lock值已经为1，且又有进程&#x2F;线程要获取这个锁时，将lock置为2，表示发生了竞争</p>
</li>
</ul>
</li>
<li><p>__kind的是一个32位的整数，库的设计者将这个32字节分成几个部分来提通不同的分类方式</p>
<ul>
<li>其中的第1到第7位，代表一个锁的类别。<ul>
<li><code>PTHREAD_MUTEX_TIMED_NP</code>是mutex的默认类型，它是非递归的，这最常用的锁类别。</li>
<li><code>PTHREAD_MUTEX_RECURSIVE_NP</code>则表示可重入锁。</li>
</ul>
</li>
<li>它的第8位表示<strong>该锁是用在进程间同步还是线程间同步</strong>，通常情况下我们在线程同步中使用mutex，此时只需要将mutex声明在全局数据段即可；但如果是进程间的同步，则需要先开辟一个共享内存，将mutex放入共享内存中，然后不同进程才能操作同一个mutex。</li>
</ul>
</li>
<li><p>__count是给可重入锁使用的，如果同一个线程重复对同一个mutex加锁，则对该属性进行递增即可。</p>
</li>
</ul>
<p><strong>pthread_mutex_lock</strong></p>
<ul>
<li>加锁lock()的逻辑很简单，首先在用户态利用CAS判断是否发生冲突，如果CAS返回0，那么直接返 回;如果CAS返回1或者2，进入futex系统调用，交由操作系统仲裁</li>
</ul>
<p><strong>pthread_mutex_unlock</strong></p>
<ul>
<li>解锁unlock()的逻辑类似，同样需要通过CAS，如果lock的旧值是1，那么只有当前线程占用该锁，直接返回;如果lock的旧值是2，说明超过一个线程发生了竞争，调用futex系统调用唤醒其它线程。</li>
</ul>
<h3 id="1-2-2-内核态"><a href="#1-2-2-内核态" class="headerlink" title="1.2.2 内核态"></a>1.2.2 内核态</h3><ul>
<li>当一个线程需要等待一个锁而陷入睡眠时，内核会为其分配一个futex_q结构，一切的唤醒、睡眠操作都需要先找到这个futex_q结构。</li>
<li>但如果争抢情况比较激烈，那么内核存在的futex_q结构会有很多，如何快速查找对应的futex_q？内核的解决办法是使用<strong>哈希表</strong>，因为哈希表的查询、插入操作都是O(1)的时间复杂度。如上图所示，内核使用开链法处理哈希碰撞。</li>
</ul>
<div style="text-align:center;">
    <img src="futex.png" srcset="/img/loading.gif" lazyload alt="futex.png" width="409" height="237" class="jop-noMdConv">
</div>

<p><strong>hash表的key问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">futex_key</span> &#123;<br>    <span class="hljs-keyword">struct</span> &#123;<br>        u64 i_seq;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;<br>    &#125; shared;  <span class="hljs-comment">//不同进程间通过文件共享futex变量，表明该变量在文件中的位置</span><br><br>    <span class="hljs-keyword">struct</span> &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *mm;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;<br>    &#125; <span class="hljs-keyword">private</span>;  <span class="hljs-comment">//同一进程的不同线程共享futex变量，表明该变量在进程地址空间中的位置</span><br><br>    <span class="hljs-keyword">struct</span> &#123;<br>        u64 ptr;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> word;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;<br>    &#125; both;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>futex_key.private对于非共享的使用虚拟地址作为key</p>
<ul>
<li><p>如果被用来进行线程间同步，那么futex的虚拟地址在不同的线程间是相同的，因此只需要使用虚拟地址就可以唯一地标识同一线程组（进程）中的某个futex。</p>
</li>
<li><p>但是内核中的hash表是系统中的所有线程共用的，不只对一个线程组服务，因此需要额外的值来标识不同线程组，linux内核选择使用 mm_struct的虚拟地址（若两个线程属于同一进程，则它们的mm_struct的地址相同，若两个线程分属不同进程，则它们的mm_struct的地址不同）。</p>
</li>
<li><p>最终linux使用(mm_struct的虚拟地址, 锁的虚拟地址)来表示一个private futex的key。</p>
</li>
</ul>
</li>
<li><p>futex_key.shared对于进程间的使用物理地址作为key</p>
<ul>
<li><p>如果futex被用来进行进程间同行，那么futex的虚拟地址在不同的进程间不一定相同，因此linux内核需要计算它的物理地址，才可能唯一地表示futex。</p>
</li>
<li><p>linux使用( inode-&gt;i_sequence, page-&gt;index, offset_within_page)标识一个shared futex地key。其中inode是用来作为共享内存载体的文件inode， page则是futex虚拟地址所对应的struct page结构（page结构在内核中唯一地对应了一个物理页），offest就是futex结构在实际物理页中偏移量。</p>
</li>
</ul>
</li>
</ul>
<p><strong>futex_wait</strong></p>
<ol>
<li><p>调用set_current_state将进程状态设置为TASK_INTERRUPTIBLE</p>
</li>
<li><p>调用queue_me将futex_q挂载到hash链表上</p>
</li>
<li><p>调用freezable_schedule进行冲调度，此后除非有其他线程唤醒本线程，本线程不会被调度器选择 执行。这就是陷入了阻塞状态的含义。（当然这里还有一些timeout机制和提前返回不陷入阻塞的额外处理）</p>
</li>
</ol>
<p><strong>futex_wake</strong></p>
<ul>
<li>找到对应的futex_q，将其记录的task_struct的进程状态设置为TASK_RUNNING。</li>
</ul>
<h1 id="二、条件变量"><a href="#二、条件变量" class="headerlink" title="二、条件变量"></a>二、条件变量</h1><blockquote>
<p>参考文献：<br><a target="_blank" rel="noopener" href="https://weakyon.com/2019/03/14/deep-understanding-of-condition-variable.html">浅析条件变量</a></p>
</blockquote>
<ul>
<li>条件变量是与互斥量相关联的一种用于多线程之间关于共享数据状态改变的通信机制，当一个动作需要另外一个动作完成时才能进行，即：当一个线程的行为依赖于另外一个线程对共享数据状态的改变时，这时候就可以使用条件变量。其实就是同步的概念。</li>
<li>较为经典的例子是生产者消费者问题，每个线程都必须关注“物品”的数量信息，如果现在还有物品消费者才能继续运行，负责应该等待；如果承载物品的结构还有空余空间，生产者才能继续添加新的物品，否则等待。</li>
<li>这里的等待其实就是通过阻塞的方式来实现，只是我们需要在特定的时候唤醒等待的线程。当然这个生产者消费者例子的核心条件是物品数量，我们可以通过C++20引入的信号量<code>std::counting_semaphore</code>来实现，但是如果我们是要针对一些条件判断来进行同步操作，则使用<code>std::condition_variable</code></li>
</ul>
<h3 id="2-1-condition-variable"><a href="#2-1-condition-variable" class="headerlink" title="2.1 condition_variable"></a>2.1 condition_variable</h3><ul>
<li><code>std::condition_variable</code>是需要结合一个<code>std::mutex</code>使用的，并且传入的参数应该是<code>std::unique_lock&lt;std::mutex&gt;</code>，这是类似<code>std::lock_guard</code>是管理锁的辅助类工具，都是RAII风格；它们是在定义时获得锁，在析构时释放锁。它们的主要区别在于unique_lock锁机制更加灵活，可以再需要的时候进行lock或者unlock调用，不非得是析构或者构造时。</li>
</ul>
<p><strong>等待</strong></p>
<ul>
<li><code>wait</code>：阻塞当前线程，直到条件变量被唤醒</li>
<li><code>wait_for</code>：阻塞当前线程，直到条件变量被唤醒，或到指定时限之后</li>
<li><code>wait_until</code>：阻塞当前线程，直到条件变量被唤醒，或直到抵达指定时间点</li>
</ul>
<p><strong>唤醒</strong></p>
<ul>
<li><code>notify_one</code>：通知一个等待线程</li>
<li><code>notify_all</code>：通知所有的等待线程</li>
</ul>
<p><strong>使用说明</strong></p>
<ul>
<li>wait操作必须传入一个锁，条件变量在阻塞时会主动放弃锁的持有权，因此我们是需要传入<code>std::unique_lock&lt;std::mutex&gt;</code>这种更加灵活的包装。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span></span>;<br><br><span class="hljs-comment">//Predicate 谓词函数，可以普通函数或者lambda表达式</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Predicate&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred)</span></span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>普通调用方式传入这个锁就可以了，但是C++还提供了一种可以再传入一个lambda表达式的接口，这个和条件变量存在的<strong>虚假唤醒</strong>有关系，需要我们通过while循环检测条件是否满足。</li>
<li>而第二个接口其实就是封装了这个循环检测过程，通过lambda表达式的方式传入这个条件判断语句。</li>
<li>notify操作则不需要任何如何传入参数，只是唤醒别的在这个条件变量上阻塞的线程。</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> work_;<br>std::mutex cvMutex;<br>std::condition_variable cv;<br><br><span class="hljs-comment">//缓存区</span><br>std::deque&lt;<span class="hljs-type">int</span>&gt; data_deque;<br><span class="hljs-comment">//缓存区最大数目</span><br><span class="hljs-type">size_t</span> max_num;<br><span class="hljs-comment">//数据</span><br><span class="hljs-type">int</span> next_index;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer_thread</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (work_) &#123;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));<br><br>    <span class="hljs-comment">//加锁</span><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cvMutex)</span></span>;<br>    <span class="hljs-comment">//当队列未满时，继续添加数据</span><br>    cv.<span class="hljs-built_in">wait</span>(lk, [<span class="hljs-keyword">this</span>]() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;data_deque.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-keyword">this</span>-&gt;max_num; &#125;);<br><br>    next_index++;<br>    data_deque.<span class="hljs-built_in">push_back</span>(next_index);<br>    <span class="hljs-comment">//唤醒其他线程</span><br>    cv.<span class="hljs-built_in">notify_all</span>();<br>    <span class="hljs-comment">//自动释放锁</span><br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer_thread</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (work_) &#123;<br>    <span class="hljs-comment">//加锁</span><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cvMutex)</span></span>;<br>    <span class="hljs-comment">//检测条件是否达成</span><br>    cv.<span class="hljs-built_in">wait</span>(lk, [<span class="hljs-keyword">this</span>] &#123; <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>-&gt;data_deque.<span class="hljs-built_in">empty</span>(); &#125;);<br><br>    <span class="hljs-comment">//互斥操作，消息数据</span><br>    <span class="hljs-type">int</span> data = data_deque.<span class="hljs-built_in">front</span>();<br>    data_deque.<span class="hljs-built_in">pop_front</span>();<br>    <span class="hljs-comment">//唤醒其他线程</span><br>    cv.<span class="hljs-built_in">notify_all</span>();<br>    <span class="hljs-comment">//自动释放锁</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>这里是一个生产者消费者的例子，公共区域是一个双向队列，那么我们访问公共区域必然是需要加锁来保证互斥访问的，也就用这里声明的<code>cvMutex</code>来保证互斥访问了，无论是生产者还是消费者在每次循环中都是先通过<code>std::unique_lock&lt;std::mutex&gt;</code>加锁来保证互斥访问。<strong>这里引出了CondVar需要绑定Mutex的第一个原因，我们在操作公共资源或者是在判断条件的时候都是需要互斥访问的，而Mutex完成了这个工作。</strong></li>
<li>但如果是对atomic这样的共享变量，是否可以不需要Mutex呢？依然不能，这是CondVar设计的核心要点，后面介绍</li>
<li>注意wait操作在阻塞时会释放掉锁，并且重新被唤醒并退出wait函数时是会重新持有锁的</li>
</ul>
<h2 id="2-2-CondVar为什么需要绑定Mutex"><a href="#2-2-CondVar为什么需要绑定Mutex" class="headerlink" title="2.2 CondVar为什么需要绑定Mutex"></a>2.2 CondVar为什么需要绑定Mutex</h2><ul>
<li>假设我们现在只有阻塞自己和唤醒别人的两个接口，不绑定Mutex，那能否实现相同的功能？我们依然是先加锁访问共享区域，如果需要阻塞等待就释放锁并阻塞自己。也就是先释放资源锁，再阻塞自己，且不是一个原子操作。</li>
<li>这里存在一个问题，以消费者生产者为例，消费者条件不满足，于是释放锁并准备阻塞自己，但刚完成解锁的操作，就被生产者获取到了并开始执行，这时，因为消费者还未挂起自己，来不及将自己的标识符保存在某个位置，所以生产者在执行唤醒操作的时候并没有唤醒这个即将阻塞的消费者。这时，切换到消费者后，消费者将永远的等待下去，虽然队列中有产品。而生产者因为队列中有产品可能也一直的等待下去，形成了死锁。</li>
<li>解决方法是必须让解锁、保存线程标识符、挂起这一系列操作成为原子操作。（当然我们不可能先挂起自己再释放锁）</li>
<li>glibc怎么做的呢？每一个condvar内部有一个额外的mutex，在pthread_cond_wait的逻辑中，首先是condvar的内部mutex lock，再是外部mutex unlock，再是内部futex wait。这样，就保证了，线程B signal一定在线程A wait之后（毕竟线程B signal也需要获取内部mutex）。</li>
</ul>
<h2 id="2-3-虚假唤醒"><a href="#2-3-虚假唤醒" class="headerlink" title="2.3 虚假唤醒"></a>2.3 虚假唤醒</h2><ul>
<li>在正常情况下，wait类型函数返回时要么是因为被唤醒，要么是因为超时才返回，但是在实际中发现，因此操作系统的原因，wait类型在不满足条件时，它也会返回，这就导致了虚假唤醒。</li>
<li>既然没有满足条件为何会被唤醒呢？原因有很多，较为经典的一个是我们有一个消费者在运行状态不断消耗生产者生产的“物品”。但是在生产者的循环中每次都会去做notify操作，此外还有可能会做notify_all操作。虽然在唤醒的时候确实还有资源可以使用，但是当被唤醒的消费者真正开始执行的时候却发现资源已经被消耗完了。</li>
<li>于是我们需要在wait结束的时候再判断一下是否符合条件，那么设计成一个while结构就可以了。</li>
</ul>
<h1 id="三、死锁"><a href="#三、死锁" class="headerlink" title="三、死锁"></a>三、死锁</h1><ul>
<li>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</li>
<li>此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</li>
</ul>
<h2 id="3-1-产生条件"><a href="#3-1-产生条件" class="headerlink" title="3.1 产生条件"></a>3.1 产生条件</h2><ul>
<li><p>产生死锁的四个必要条件：</p>
<ul>
<li><p>互斥条件：一个资源每次只能被一个进程使用。</p>
</li>
<li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
</li>
<li><p>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</p>
</li>
<li><p>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-2-解决方案"><a href="#3-2-解决方案" class="headerlink" title="3.2 解决方案"></a>3.2 解决方案</h2><h3 id="3-2-1-预防死锁"><a href="#3-2-1-预防死锁" class="headerlink" title="3.2.1 预防死锁"></a>3.2.1 预防死锁</h3><ul>
<li>预防是通过破坏产生死锁的必要条件之一，使系统不会产生死锁。</li>
</ul>
<div style="text-align:center;">
    <img src="dead_lock.png" srcset="/img/loading.gif" lazyload alt="dead_lock.png" width="637" height="280" class="jop-noMdConv">
</div>

<ul>
<li>在数据库中对B+树访问进行加锁操作时，利用了破坏循环等待条件的方法，通过指定顺序来进行加锁操作，从而保证不产生死锁。</li>
</ul>
<h3 id="3-2-2-避免死锁"><a href="#3-2-2-避免死锁" class="headerlink" title="3.2.2 避免死锁"></a>3.2.2 避免死锁</h3><ul>
<li>有一个安全状态的概念，我们将资源分配给不同的用户，如果我们提前知道每个程序最多需要申请多少资源，那当某个程序申请资源的时候，我们就可以判定如果响应这个请求之后，我们剩余的资源是否还能在未来满足某个进程的最大需要，然后等他返回资源之后，还能满足别的程序，最终保证满足所有的请求。</li>
<li>如果我们按照某个顺序响应资源请求，可以保证在任意时刻都可以有足够的剩余资源保障请求程序的需要，那么用于不会有产生死锁的可能，这是安全状态。</li>
<li>如果没有按照这种安全顺序响应请求，会有出现死锁的风险，这时是不安全状态。不安全状态不一定会出现死锁。</li>
</ul>
<p><strong>银行家算法</strong></p>
<ul>
<li>银行家算法的实质就是要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。即没当进程提出资源请求且系统的资源能够满足该请求时，系统将判断满足此次资源请求后系统状态是否安全，如果判断结果为安全，则给该进程分配资源，否则不分配资源，申请资源的进程将阻塞。</li>
</ul>
<h3 id="3-2-3-检测死锁和解除"><a href="#3-2-3-检测死锁和解除" class="headerlink" title="3.2.3 检测死锁和解除"></a>3.2.3 检测死锁和解除</h3><ul>
<li>保存有关资源的请求和分配信息，提供一种算法通过这些信息来检测系统是否已经进入死锁状态</li>
<li>检测到死锁之后应该通过某种机制让部分进程被终止，从而打破死锁</li>
</ul>
<blockquote>
<p>具体的例子看RocksDB中在事务管理上进行加锁操作时，采用PessimisticTransaction方式时如何对锁进行跟踪和死锁检测。本质上来说是检测有向图中是否存在环，采用BFS算法来实现。</p>
</blockquote>
<h1 id="四、可重入锁"><a href="#四、可重入锁" class="headerlink" title="四、可重入锁"></a>四、可重入锁</h1><ul>
<li><code>std::recursive_mutex</code>：允许在同一个线程中同一个互斥量多次被 lock() ，（但是递归加锁的次数是有限制的，太多可能会报异常），效率要比mutex低。</li>
<li>实现方式其实就是记录持有锁的线程ID，也是调用pthread_mutex_t，只不过相对于std::mutex调用pthread_mutex_t的传入参数不一样。</li>
</ul>
<blockquote>
<p>分析的c++标准库的std::shared_mutex的实现</p>
</blockquote>
<ul>
<li><p>c++在c++14以上的版本引入了shared_mutex，实现了读写锁的语义。实际上，它的读写锁有两种实现：第一种就是封装操作系统的，其实就是封装了glibc的读写锁实现(只不过这种实现是依托于操作系统本身是posix还是windows的，所以多加了一层shared_mutex来实现统一)；第二种是c++自己的实现。</p>
</li>
<li><p>它们的区别就是是否定义了_GLIBCXX_USE_PTHREAD_RWLOCK_T这个宏。如果定义了，就直接用glibc中的pthread_rwlock_t；如果没定义，就用libstdc++中实现的__shared_mutex_cv</p>
</li>
</ul>
<h1 id="五、读写锁"><a href="#五、读写锁" class="headerlink" title="五、读写锁"></a>五、读写锁</h1><h2 id="5-1-优先倾向"><a href="#5-1-优先倾向" class="headerlink" title="5.1 优先倾向"></a>5.1 优先倾向</h2><p><strong>读者优先</strong></p>
<ul>
<li>如果当前读者持有锁，那么读者想进就优先进，不用管写者是不是有想进的；如果当前是写者持有锁，那么写者释放锁之后优先唤醒读者。</li>
</ul>
<p><strong>写者优先</strong>：</p>
<ul>
<li>如果当前是写持有锁，那么写者直接排在队列最前面；如果当前是读者持有锁，那么写者设置一个意向。读者上锁时，如果有这个意向存在，那么也不能进入。</li>
</ul>
<p><strong>公平</strong>：</p>
<ul>
<li><p>如果当前读者持有锁，那么读者和作者在同一个队列上排布。当出现可以进入时，操作系统来决定让读者或者作者进入。</p>
</li>
<li><p>如果单纯判断当前的read_count个数，比如read_count &gt; 1，那么一定进入，此时就是读者优先；如果此时还要判断作者的意向，比如write_entered &#x3D; true时不进入，此时就不是读者优先，但也不一定是写者优先</p>
</li>
<li><p>如果作者解锁的时候优先唤醒读者，那显然是读者优先；如果写者解锁的时候优先唤醒写者，那显然是写者优先；如果写者解锁的时候随机唤醒，那么就是公平策略。</p>
</li>
</ul>
<h2 id="5-2-libstdc-的实现"><a href="#5-2-libstdc-的实现" class="headerlink" title="5.2 libstdc++的实现"></a>5.2 libstdc++的实现</h2><h3 id="5-2-1-类定义"><a href="#5-2-1-类定义" class="headerlink" title="5.2.1 类定义"></a>5.2.1 类定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_mutex</span><br>&#123;<br>    mutex    _M_mut; <span class="hljs-comment">// 保护对_M_state、gate1_、gate2_的访问</span><br>    cond_var gate1_; <span class="hljs-comment">// 用于在writer存在时(或reader达到最大值时,只不过这种情况几乎不会发生) 阻塞reader/writer</span><br>    cond_var gate2_; <span class="hljs-comment">// 用于在reader非0时 阻塞writer</span><br>    <span class="hljs-type">unsigned</span> _M_state; <span class="hljs-comment">// 最高bit表示writer已经获取锁或正在排队等待获取锁(即write-entered被设置) 其余bit表示reader锁定的个数</span><br>    <br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> _S_write_entered<br>      = <span class="hljs-number">1U</span> &lt;&lt; (<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unsigned</span>)*__CHAR_BIT__ - <span class="hljs-number">1</span>); <span class="hljs-comment">// 二进制表现为1后面31个0 相当于一个筛选器，用于按位与</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> _S_max_readers = ~_S_write_entered; <span class="hljs-comment">// 二进制表现为0后面31个1 用于按位与</span><br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">shared_mutex</span>() : <span class="hljs-built_in">state_</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br><span class="hljs-comment">// Exclusive ownership</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_lock</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">timed_lock</span><span class="hljs-params">(nanoseconds rel_time)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// Shared ownership</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock_shared</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_lock_shared</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">timed_lock_shared</span><span class="hljs-params">(nanoseconds rel_time)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock_shared</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>成员变量的核心在两个条件变量和状态标识符上</p>
<ul>
<li><p><code>gate1_</code>用于有写线程时阻塞其他的读&#x2F;写线程，<code>gate2_</code>用于有读线程时阻塞写线程。</p>
</li>
<li><p>状态标识符号表示目前是否有写线程在等待或者占用，此外还表示当前读线程的数量。</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-2-2-读锁"><a href="#5-2-2-读锁" class="headerlink" title="5.2.2 读锁"></a>5.2.2 读锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shared_mutex::lock_shared</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 1.首先锁住_M_mut，保护对_M_state的独占访问(这里上锁的原因可以参考为什么condvar需要mutex的参与)</span><br>	unique_lock&lt;mutex&gt; __lk(_M_mut);<br>	<span class="hljs-comment">// 2. 判断reader是否可以进入 </span><br>	<span class="hljs-comment">// 这里的_M_state &lt; _S_max_readers其实有两层含义</span><br>	<span class="hljs-comment">// 2.1 如果_M_state最高位为1，此时等式不成立，会在这里锁住；这里代表的语义就是writer正在写，reader不要进入</span><br>	<span class="hljs-comment">// 2.2 如果_M_state最高位不为1，但最低31位均为1，此时等式不成立，会在这里锁住；这里代表的语义就是reader满了，新的reader不要进入</span><br>    _M_gate1.<span class="hljs-built_in">wait</span>(__lk, [=]&#123; <span class="hljs-keyword">return</span> _M_state &lt; _S_max_readers; &#125;);<br>    <span class="hljs-comment">// 3. reader成功进入，增加readers数量</span><br>    ++_M_state;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shared_mutex::unlock_shared</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 1. 首先锁住_M_mut，保护对_M_state的独占修改</span><br>	lock_guard&lt;mutex&gt; __lk(_M_mut);<br>	__glibcxx_assert( _M_readers() &gt; <span class="hljs-number">0</span> );<br>	<span class="hljs-comment">// 2. 修改reader数量，减一</span><br>	<span class="hljs-keyword">auto</span> __prev = _M_state--;<br>	<span class="hljs-comment">// 3. 判断当前是否有writer想要进入</span><br>	<span class="hljs-keyword">if</span> (_M_write_entered())<br>	&#123;<br>		<span class="hljs-comment">// Wake the queued writer if there are no more readers.</span><br>		<span class="hljs-keyword">if</span> (_M_readers() == <span class="hljs-number">0</span>)<br>			_M_gate2.<span class="hljs-built_in">notify_one</span>();<br>		<span class="hljs-comment">// No need to notify gate1 because we give priority to the queued</span><br>		<span class="hljs-comment">// writer, and that writer will eventually notify gate1 after it</span><br>		<span class="hljs-comment">// clears the write-entered flag.</span><br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-comment">// Wake any thread that was blocked on reader overflow.</span><br>		<span class="hljs-keyword">if</span> (__prev == _S_max_readers)<br>		_M_gate1.<span class="hljs-built_in">notify_one</span>();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>加读锁的逻辑是，如果目前没有写锁占用或者写锁等待，就直接加锁。所以我们只需要在<code>gate1_</code>上面进行条件等待</p>
</li>
<li><p>解锁的时候，需要唤醒在等待的写锁请求，因此需要去唤醒<code>gate2_</code>；这里还有一个else的情况是针对加读锁超过最大数量的情况下唤醒<code>gate2_</code>，一般不可能存在这种情况</p>
</li>
</ul>
<h3 id="5-2-3-写锁"><a href="#5-2-3-写锁" class="headerlink" title="5.2.3 写锁"></a>5.2.3 写锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shared_mutex::lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 1. 首先锁住_M_mut，保护对_M_state的独占访问(这里上锁的原因可以参考为什么condvar需要mutex的参与)</span><br>    unique_lock&lt;mutex&gt; __lk(_M_mut);<br>    <span class="hljs-comment">// 2. 如果有其他writer正在占用，则阻塞在_M_gate1上</span><br>    _M_gate1.<span class="hljs-built_in">wait</span>(__lk, [=]&#123; <span class="hljs-keyword">return</span> !_M_write_entered(); &#125;);<br>    <span class="hljs-comment">// 3. 设置_M_state最高位为1，让writer保持&quot;想要访问&quot;的状态</span><br>    _M_state |= _S_write_entered;<br>    <span class="hljs-comment">// 4. 如果由readers正在占用，则阻塞在_M_gate2上</span><br>    _M_gate2.<span class="hljs-built_in">wait</span>(__lk, [=]&#123; <span class="hljs-keyword">return</span> _M_readers() == <span class="hljs-number">0</span>; &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shared_mutex::unlock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 1. 首先锁住_M_mut，保护对_M_state的独占访问(这里上锁的原因可以参考为什么condvar需要mutex的参与)</span><br>    lock_guard&lt;mutex&gt; __lk(_M_mut);<br>    __glibcxx_assert( _M_write_entered() );<br>    <span class="hljs-comment">// 2. 设置_M_state最高位为0</span><br>    _M_state = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// 3. 唤醒沉睡在_M_gate1上的线程</span><br>    _M_gate1.<span class="hljs-built_in">notify_all</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>写锁请求存在两个阻塞点，首先会被写锁阻塞，这里是被阻塞在<code>gate1_</code>上的；第二种情况是被读锁阻塞的，被阻塞在<code>gate2_</code>上。需要注意，我们在<code>gate1_</code>这一步上因为需要判断<code>_S_write_entered</code>是否为0，所以永远只可能存在1个写请求等待在<code>gate2_</code>上。</p>
</li>
<li><p>并且当持有写锁时，<code>gate2_</code>上不会有写锁请求存在，后面到达的写锁请求只会阻塞到<code>gate1_</code>上。因此解锁阶段，只需要唤醒<code>gate1_</code>即可。</p>
</li>
</ul>
<h3 id="5-2-4-公平保证"><a href="#5-2-4-公平保证" class="headerlink" title="5.2.4 公平保证"></a>5.2.4 公平保证</h3><ul>
<li><p>只要有写线程进入<code>gate2_</code>开始等待，<code>_S_write_entered</code>就会被设置，此后有读请求到来时因为存在<code>_M_state &lt; _S_max_readers;</code>条件，就会被一直阻塞在<code>gate1_</code>上。达成这种状态的情况是当前读锁占用，然后到达的第一个写锁请求。</p>
</li>
<li><p>但是如果当前被写锁占用，所有后到达的读&#x2F;写锁请求都被阻塞在<code>gate1_</code>，那么就是公平竞争的。</p>
</li>
</ul>
<h2 id="5-3-glibc的实现"><a href="#5-3-glibc的实现" class="headerlink" title="5.3 glibc的实现"></a>5.3 glibc的实现</h2><p>&nbsp;</p>
<h1 id="六、乐观锁与悲观锁"><a href="#六、乐观锁与悲观锁" class="headerlink" title="六、乐观锁与悲观锁"></a>六、乐观锁与悲观锁</h1><ul>
<li>这两种概念并不是指一种具体的锁实现，而是指一种控制并发访问的理念，是程序设计上的概念。</li>
</ul>
<p><strong>悲观锁</strong></p>
<ul>
<li>其实互斥锁、自旋锁、读写锁，都是属于悲观锁。</li>
<li>悲观锁做事比较悲观，它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁</strong>。</li>
</ul>
<p><strong>乐观锁</strong></p>
<ul>
<li>那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。</li>
<li>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作</strong>。</li>
<li>放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。<strong>乐观锁全程并没有加锁，所以它也叫无锁编程</strong>。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux/" class="category-chain-item">Linux</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Linux/" class="print-no-link">#Linux</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Linux:同步与锁</div>
      <div>https://lluvialuo.github.io/2024/05/12/Linux-同步与锁/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lluvia Luo</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/05/12/Linux-%E6%96%87%E4%BB%B6IO/" title="Linux:文件IO">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux:文件IO</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/12/Linux-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="Linux:进程管理">
                        <span class="hidden-mobile">Linux:进程管理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"GYXWwiquLells7Jk5YnXDL14-gzGzoHsz","appKey":"ZwOt64lE5AeeAOjGF9nhJl9b","path":"window.location.pathname","placeholder":"说点什么。。。","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
